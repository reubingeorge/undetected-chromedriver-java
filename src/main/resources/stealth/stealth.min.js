// Comprehensive stealth evasions - minified version
// This combines all the individual evasions into one file

(function() {
    'use strict';

    // Helper to define property safely
    const safeDefineProperty = (obj, prop, descriptor) => {
        try {
            const existing = Object.getOwnPropertyDescriptor(obj, prop);
            if (!existing || existing.configurable) {
                Object.defineProperty(obj, prop, descriptor);
                return true;
            }
        } catch (e) {}
        return false;
    };

    // Helper to override function
    const overrideFunction = (obj, funcName, newFunc) => {
        try {
            const original = obj[funcName];
            obj[funcName] = new Proxy(original, {
                apply: function(target, thisArg, argumentsList) {
                    return newFunc.call(thisArg, target, argumentsList);
                }
            });
        } catch (e) {}
    };

    // 1. Navigator.webdriver evasion
    safeDefineProperty(navigator, 'webdriver', {
        get: () => undefined,
        configurable: true
    });

    // Remove webdriver from window object
    if (window.navigator.webdriver) {
        delete window.navigator.webdriver;
    }

    // 2. Chrome object evasion
    if (!window.chrome) {
        window.chrome = {
            app: {
                isInstalled: false,
                InstallState: {
                    DISABLED: 'disabled',
                    INSTALLED: 'installed',
                    NOT_INSTALLED: 'not_installed'
                },
                RunningState: {
                    CANNOT_RUN: 'cannot_run',
                    READY_TO_RUN: 'ready_to_run',
                    RUNNING: 'running'
                }
            },
            runtime: {
                OnInstalledReason: {
                    CHROME_UPDATE: 'chrome_update',
                    INSTALL: 'install',
                    SHARED_MODULE_UPDATE: 'shared_module_update',
                    UPDATE: 'update'
                },
                OnRestartRequiredReason: {
                    APP_UPDATE: 'app_update',
                    OS_UPDATE: 'os_update',
                    PERIODIC: 'periodic'
                },
                PlatformArch: {
                    ARM: 'arm',
                    ARM64: 'arm64',
                    MIPS: 'mips',
                    MIPS64: 'mips64',
                    X86_32: 'x86-32',
                    X86_64: 'x86-64'
                },
                PlatformNaclArch: {
                    ARM: 'arm',
                    MIPS: 'mips',
                    MIPS64: 'mips64',
                    X86_32: 'x86-32',
                    X86_64: 'x86-64'
                },
                PlatformOs: {
                    ANDROID: 'android',
                    CROS: 'cros',
                    LINUX: 'linux',
                    MAC: 'mac',
                    OPENBSD: 'openbsd',
                    WIN: 'win'
                },
                RequestUpdateCheckStatus: {
                    NO_UPDATE: 'no_update',
                    THROTTLED: 'throttled',
                    UPDATE_AVAILABLE: 'update_available'
                },
                id: undefined,
                connect: function() { return {} },
                sendMessage: function() {}
            },
            csi: function() {},
            loadTimes: function() {
                return {
                    commitLoadTime: 0,
                    connectionInfo: 'h2',
                    finishDocumentLoadTime: 0,
                    finishLoadTime: 0,
                    firstPaintAfterLoadTime: 0,
                    firstPaintTime: 0,
                    navigationType: 'Other',
                    npnNegotiatedProtocol: 'h2',
                    requestTime: 0,
                    startLoadTime: 0,
                    wasAlternateProtocolAvailable: false,
                    wasFetchedViaSpdy: true,
                    wasNpnNegotiated: true
                }
            }
        };
    }

    // 3. Navigator.plugins evasion
    const mockPlugins = [
        {
            name: 'Chrome PDF Plugin',
            filename: 'internal-pdf-viewer',
            description: 'Portable Document Format',
            mimeTypes: [{
                type: 'application/x-google-chrome-pdf',
                suffixes: 'pdf',
                description: 'Portable Document Format'
            }]
        },
        {
            name: 'Chrome PDF Viewer',
            filename: 'mhjfbmdgcfjbbpaeojofohoefgiehjai',
            description: 'Portable Document Format',
            mimeTypes: [{
                type: 'application/pdf',
                suffixes: 'pdf',
                description: 'Portable Document Format'
            }]
        },
        {
            name: 'Native Client',
            filename: 'internal-nacl-plugin',
            description: 'Native Client Executable',
            mimeTypes: [
                {
                    type: 'application/x-nacl',
                    suffixes: '',
                    description: 'Native Client Executable'
                },
                {
                    type: 'application/x-pnacl',
                    suffixes: '',
                    description: 'Portable Native Client Executable'
                }
            ]
        }
    ];

    // Create PluginArray mock
    const pluginArray = {
        length: mockPlugins.length,
        item: function(index) {
            return this[index] || null;
        },
        namedItem: function(name) {
            for (let i = 0; i < this.length; i++) {
                if (this[i].name === name) return this[i];
            }
            return null;
        },
        refresh: function() {}
    };

    // Create MimeTypeArray mock
    const mimeTypeArray = {
        length: 0,
        item: function(index) {
            return this[index] || null;
        },
        namedItem: function(name) {
            for (let i = 0; i < this.length; i++) {
                if (this[i].type === name) return this[i];
            }
            return null;
        }
    };

    // Add plugins to array
    mockPlugins.forEach((plugin, index) => {
        const pluginObj = {
            name: plugin.name,
            filename: plugin.filename,
            description: plugin.description,
            length: plugin.mimeTypes.length
        };

        // Add mime types to plugin
        plugin.mimeTypes.forEach((mimeType, mimeIndex) => {
            const mimeTypeObj = {
                type: mimeType.type,
                suffixes: mimeType.suffixes,
                description: mimeType.description,
                enabledPlugin: pluginObj
            };
            pluginObj[mimeIndex] = mimeTypeObj;
            mimeTypeArray[mimeTypeArray.length++] = mimeTypeObj;
        });

        pluginArray[index] = pluginObj;
    });

    // Override navigator.plugins
    safeDefineProperty(navigator, 'plugins', {
        get: () => pluginArray,
        configurable: true
    });

    // Override navigator.mimeTypes
    safeDefineProperty(navigator, 'mimeTypes', {
        get: () => mimeTypeArray,
        configurable: true
    });

    // 4. Navigator.permissions evasion
    if (navigator.permissions) {
        const originalQuery = navigator.permissions.query.bind(navigator.permissions);

        overrideFunction(navigator.permissions, 'query', function(original, args) {
            const parameters = args[0];

            // Modify behavior for certain permissions
            if (parameters.name === 'notifications') {
                return Promise.resolve({
                    state: 'prompt',
                    onchange: null
                });
            }

            if (parameters.name === 'push') {
                return Promise.resolve({
                    state: 'prompt',
                    onchange: null
                });
            }

            // Default behavior for other permissions
            return original.apply(this, args);
        });
    }

    // 5. Navigator.languages evasion
    safeDefineProperty(navigator, 'languages', {
        get: () => ['en-US', 'en'],
        configurable: true
    });

    // 6. WebGL Vendor evasion
    const getParameter = WebGLRenderingContext.prototype.getParameter;
    WebGLRenderingContext.prototype.getParameter = function(parameter) {
        // UNMASKED_VENDOR_WEBGL
        if (parameter === 37445) {
            return 'Intel Inc.';
        }
        // UNMASKED_RENDERER_WEBGL
        if (parameter === 37446) {
            return 'Intel Iris OpenGL Engine';
        }
        return getParameter.call(this, parameter);
    };

    const getParameter2 = WebGL2RenderingContext.prototype.getParameter;
    WebGL2RenderingContext.prototype.getParameter = function(parameter) {
        // UNMASKED_VENDOR_WEBGL
        if (parameter === 37445) {
            return 'Intel Inc.';
        }
        // UNMASKED_RENDERER_WEBGL
        if (parameter === 37446) {
            return 'Intel Iris OpenGL Engine';
        }
        return getParameter2.call(this, parameter);
    };

    // 7. Canvas fingerprint protection
    const toDataURL = HTMLCanvasElement.prototype.toDataURL;
    HTMLCanvasElement.prototype.toDataURL = function() {
        const context = this.getContext('2d');
        if (context) {
            // Add minimal noise to canvas
            const imageData = context.getImageData(0, 0, this.width, this.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                imageData.data[i] = imageData.data[i] + (Math.random() * 0.5 - 0.25);
                imageData.data[i+1] = imageData.data[i+1] + (Math.random() * 0.5 - 0.25);
                imageData.data[i+2] = imageData.data[i+2] + (Math.random() * 0.5 - 0.25);
            }
            context.putImageData(imageData, 0, 0);
        }
        return toDataURL.apply(this, arguments);
    };

    // 8. AudioContext fingerprint protection
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (AudioContext) {
        const audioContextPrototype = AudioContext.prototype;
        const originalCreateOscillator = audioContextPrototype.createOscillator;
        const originalCreateDynamicsCompressor = audioContextPrototype.createDynamicsCompressor;

        audioContextPrototype.createOscillator = function() {
            const oscillator = originalCreateOscillator.apply(this, arguments);
            const originalConnect = oscillator.connect;

            oscillator.connect = function() {
                const gainNode = this.context.createGain();
                gainNode.gain.value = 0.9999999;
                originalConnect.call(this, gainNode);
                return gainNode.connect.apply(gainNode, arguments);
            };

            return oscillator;
        };

        audioContextPrototype.createDynamicsCompressor = function() {
            const compressor = originalCreateDynamicsCompressor.apply(this, arguments);
            compressor.threshold.value = -50.1;
            compressor.knee.value = 40.1;
            compressor.ratio.value = 12.1;
            compressor.reduction.value = -20.1;
            compressor.attack.value = 0.001;
            compressor.release.value = 0.251;
            return compressor;
        };
    }

    // 9. Battery API evasion
    if (navigator.getBattery) {
        navigator.getBattery = async function() {
            return {
                charging: true,
                chargingTime: 0,
                dischargingTime: Infinity,
                level: 1.0,
                addEventListener: function() {},
                removeEventListener: function() {}
            };
        };
    }

    // 10. Connection API evasion
    if (navigator.connection) {
        safeDefineProperty(navigator.connection, 'rtt', {
            get: () => 50,
            configurable: true
        });
    }

    // 11. Hide automation indicators
    ['webdriver', '_Selenium_IDE_Recorder', '_selenium', 'calledSelenium',
        '_WEBDRIVER_ELEM_CACHE', 'ChromeDriverw', 'driver-evaluate', 'webdriver-evaluate',
        'selenium-evaluate', 'webdriverCommand', 'webdriver-evaluate-response',
        '__webdriverFunc', '__driver_evaluate', '__webdriver_evaluate', '__driver_unwrapped',
        '__webdriver_unwrapped', '__webdriver_script_function', '__webdriver_script_func',
        '__webdriver_script_fn', '__fxdriver_evaluate', '__driver_evaluate', '__webdriver_unwrapped',
        '__webdriver_func', '__webdriver_scripts', '__$webdriverAsyncExecutor',
        '__lastWatirAlert', '__lastWatirConfirm', '__lastWatirPrompt', '$chrome_asyncScriptInfo',
        '$cdc_asdjflasutopfhvcZLmcfl_'].forEach(prop => {
        try {
            delete window[prop];
            delete document[prop];
        } catch (e) {}
    });

    // 12. Console.debug fix
    const consoleDebug = console.debug;
    console.debug = function() {
        if (arguments[0] && arguments[0].toString().indexOf('Runtime.enable') === -1) {
            consoleDebug.apply(console, arguments);
        }
    };

})();